import { Xendit } from 'xendit-node';

const xenditClient = new Xendit({
  secretKey: process.env.XENDIT_SECRET_KEY || 'xnd_development_jh4wbsXcaD6bnhpwtnINjV6mEPTG6PeUiwH1oQr3BUpV3VzXMlEPX7JH28ahfuAo',
});

// Check if we have valid API keys (not placeholder)
const hasValidKeys = process.env.XENDIT_SECRET_KEY && 
  !process.env.XENDIT_SECRET_KEY.includes('placeholder') &&
  !process.env.XENDIT_SECRET_KEY.includes('YOUR_SECRET_KEY_HERE') &&
  process.env.XENDIT_SECRET_KEY.startsWith('xnd_') &&
  !process.env.XENDIT_SECRET_KEY.includes('YOUR_PRODUCTION_KEY_HERE') &&
  process.env.XENDIT_SECRET_KEY.length > 50; // Ensure key is complete

const { Invoice, PaymentMethod } = xenditClient;

export const xendit = {
  /**
   * Create a payment invoice
   */
  async createInvoice(params: {
    externalId: string;
    amount: number;
    description: string;
    payerEmail?: string;
    customer?: {
      givenNames: string;
      email: string;
      mobileNumber?: string;
    };
    items?: Array<{
      name: string;
      quantity: number;
      price: number;
      category?: string;
      url?: string;
    }>;
    fees?: Array<{
      type: string;
      value: number;
    }>;
  }) {
    console.log('Creating invoice with params:', params);
    console.log('Has valid keys:', hasValidKeys);
    console.log('API Key:', process.env.XENDIT_SECRET_KEY?.substring(0, 10) + '...');
    
    if (!hasValidKeys) {
      // Mock response for development
      console.log('Using MOCK response - this will NOT appear in Xendit dashboard');
      return {
        id: `mock_invoice_${Date.now()}`,
        invoice_url: `https://checkout.xendit.co/web/${Date.now()}`,
        status: 'PENDING',
        amount: params.amount,
        description: params.description,
        externalId: params.externalId,
      };
    }

    try {
      console.log('Using REAL Xendit API - this WILL appear in dashboard');
      const response = await Invoice.createInvoice({
        data: {
          amount: params.amount,
          invoiceDuration: 86400,
          externalId: params.externalId,
          description: params.description,
          currency: 'IDR',
          payerEmail: params.payerEmail,
          customer: params.customer,
          items: params.items,
          fees: params.fees,
          successRedirectUrl: `http://localhost:3000/payment/success`,
          failureRedirectUrl: `http://localhost:3000/payment/failed`,
        },
      });

      console.log('Xendit API response:', response);
      return response;
    } catch (error) {
      console.error('Error creating Xendit invoice:', error);
      throw error;
    }
  },

  /**
   * Get invoice details
   */
  async getInvoice(invoiceId: string) {
    try {
      const response = await Invoice.getInvoiceById({ 
        invoiceId,
      });

      return response;
    } catch (error) {
      console.error('Error getting Xendit invoice:', error);
      throw error;
    }
  },

  /**
   * Create a virtual account
   */
  async createVirtualAccount(params: {
    externalId: string;
    bankCode: 'BCA' | 'BNI' | 'MANDIRI' | 'CIMB' | 'PERMATA' | 'BSI' | 'DANAMON';
    name: string;
    expectedAmount?: number;
    isClosed?: boolean;
    description?: string;
  }) {
    if (!hasValidKeys) {
      // Mock response for development
      console.log('Mock Xendit Virtual Account (Development Mode):', params);
      return {
        id: `mock_va_${Date.now()}`,
        virtualAccount: {
          accountNumber: `${params.bankCode.toLowerCase()}1234567890`,
          channelCode: params.bankCode,
          name: params.name,
        },
        status: 'ACTIVE',
      };
    }

    try {
      const response = await PaymentMethod.createPaymentMethod({
        data: {
          type: 'VIRTUAL_ACCOUNT',
          virtualAccount: {
            channelCode: params.bankCode as any, // Type assertion to bypass strict typing
            channelProperties: {
              // Add minimal channel properties as required by the SDK
              customerName: params.name,
              virtualAccountNumber: '', // Will be generated by Xendit
            },
          },
          referenceId: params.externalId,
          reusability: 'ONE_TIME_USE',
        },
      });

      return response;
    } catch (error) {
      console.error('Error creating virtual account:', error);
      throw error;
    }
  },

  /**
   * Create E-Wallet charge
   */
  async createEwalletCharge(params: {
    externalId: string;
    amount: number;
    phone: string;
    ewalletType: 'OVO' | 'DANA' | 'SHOPEEPAY' | 'LINKAJA';
    callbackUrl?: string;
  }) {
    if (!hasValidKeys) {
      // Mock response for development - simulate real Xendit e-wallet flow
      console.log('Mock Xendit E-Wallet (Development Mode):', params);
      return {
        id: `mock_ewallet_${Date.now()}`,
        business_id: 'mock_business_id',
        reference_id: params.externalId,
        status: 'PENDING',
        amount: params.amount,
        checkout_url: `https://checkout.xendit.co/web/${Date.now()}`,
        created: new Date().toISOString(),
        updated: new Date().toISOString(),
        payment_method: {
          type: 'EWALLET',
          properties: {
            external_id: params.externalId,
            channel_code: params.ewalletType,
            success_return_url: `${process.env.NEXTAUTH_URL}/payment/success`,
            failure_return_url: `${process.env.NEXTAUTH_URL}/payment/failed`,
            cancel_return_url: `${process.env.NEXTAUTH_URL}/payment/failed`,
          }
        },
        metadata: {
          phone: params.phone,
          amount: params.amount,
        }
      };
    }

    try {
      const response = await PaymentMethod.createPaymentMethod({
        data: {
          type: 'EWALLET',
          ewallet: {
            channelCode: params.ewalletType,
            channelProperties: {
              successReturnUrl: `${process.env.NEXTAUTH_URL}/payment/success`,
              failureReturnUrl: `${process.env.NEXTAUTH_URL}/payment/failed`,
              cancelReturnUrl: `${process.env.NEXTAUTH_URL}/payment/failed`,
            },
          },
          referenceId: params.externalId,
          reusability: 'ONE_TIME_USE',
          metadata: {
            phone: params.phone,
            amount: params.amount,
          },
        },
      });

      return response;
    } catch (error) {
      console.error('Error creating e-wallet charge:', error);
      throw error;
    }
  },

  /**
   * Create QRIS payment
   */
  async createQRISCharge(params: {
    externalId: string;
    amount: number;
    callbackUrl?: string;
  }) {
    if (!hasValidKeys) {
      // Mock response for development
      console.log('Mock Xendit QRIS (Development Mode):', params);
      return {
        id: `mock_qris_${Date.now()}`,
        qrCodeUrl: `https://mock-payment.xendit.co/qris/${Date.now()}`,
        status: 'PENDING',
        amount: params.amount,
      };
    }

    try {
      // For QRIS, we'll use a simplified approach since the exact API structure may vary
      // This is a mock implementation that can be adjusted based on actual Xendit QR Code API
      return {
        id: `qris_${Date.now()}`,
        qrCodeUrl: `https://mock-payment.xendit.co/qris/${Date.now()}`,
        status: 'PENDING',
        amount: params.amount,
      };
    } catch (error) {
      console.error('Error creating QRIS charge:', error);
      throw error;
    }
  },

  /**
   * Verify payment callback
   */
  verifyCallbackToken(token: string): boolean {
    try {
      // For now, return true for development
      // In production, implement proper webhook verification
      // using Xendit's webhook verification method
      return token === process.env.XENDIT_WEBHOOK_TOKEN;
    } catch (error) {
      console.error('Error verifying webhook token:', error);
      return false;
    }
  },
};

export type XenditInvoiceResponse = Awaited<ReturnType<typeof xendit.createInvoice>>;
export type XenditVirtualAccountResponse = Awaited<ReturnType<typeof xendit.createVirtualAccount>>;
export type XenditEwalletResponse = Awaited<ReturnType<typeof xendit.createEwalletCharge>>;
